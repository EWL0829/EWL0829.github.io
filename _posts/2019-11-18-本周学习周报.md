---
layout:     post
title:      2019-11-18-学习周报
subtitle:   JavaScript基础
date:       2019-11-18
author:     EWL
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - 前端
    - JavaScript
    - 基础
    - CSS3
---

## 学习总览
**JavaScript**
- 运行机制
  - 渲染引擎
  - JavaScript引擎
  - 运行时
  - 调用栈
  - 事件循环 

**CSS**
- 
----

## 学习内容
#### （1）JavaScript运行机制
**谈谈线程问题**
JavaScript是一门单线程运行的语言。那么为什么JavaScript是单线程呢？我们可以假设JavaScript是多线程的，线程1和线程2并行，线程1删除了DOM节点A，线程2却要修改DOM节点A，那么当线程2操作该节点的时候我们到底该怎么处理呢？这种不确定性导致我们必须保证DOM的状态是唯一的，所以JavaScript变成了一门单线程语言。

**同步异步**
既然都说了JavaScript是单线程的，那么必然就会存在执行内容拥堵的情况，例如最常见的网络请求，当请求发给后端的时候，我们是不会等到数据回来再执行接下来的代码的，所以任务执行就分成了两种：
- 同步任务 
- 异步任务

当主线程遇到同步任务时会直接执行，并且这些同步任务的执行会形成一个执行栈，而当主线程碰到异步任务的时候，异步任务会暂时性地被跳过，让主线程接着去执行接下来其他的同步任务，当那些暂时被跳过的异步任务有了结果，就会立即被推进一个任务队列（task queue），等到主线程空出来后，主线程会主动去检查这个任务队列，看里面都有什么内容等待执行，然后依次执行即可，这里有一个很关键的点，如果我们写了两个平行关系的ajax请求，那么这两个异步请求的回调谁先执行是不确定的，原因就是异步请求谁先进入任务队列的顺序在没有经过限制（例如promise的then回调限制）的情况下是不确定的。
说了这么多，我们还是放个图来直观感受一下吧：
![image.png](https://image-static.segmentfault.com/254/700/2547003348-5a6f118c259c4_articlex)


**宏任务/微任务**
**运行时**
**回调队列**
**浏览器（渲染引擎、JS引擎）**

**借助一道面试题小试牛刀**
在搜集资料的过程中，我发现了一道频繁出现的头条面试题，在体现JavaScript运行机制与运行顺序这两个知识点上很有代表性，代码如下：
```
async function async1() {
   console.log("async1 start");
   await  async2();
   console.log("async1 end");
}
    
async  function async2() {
  console.log( 'async2');
}
    
console.log("script start");

setTimeout(function () {
  console.log("settimeout");
},0);

async1();

new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});

console.log('script end');
```
上面这段代码的运行结果，我们事先给出来：
```
script start;
async1 start;
async2;
promise1;
script end;
async1 end;
promise1;
settimeout;
```
也许这段输出结果和我们预先猜想的不同，没关系，我们现在就开始分析这到底是怎么回事。
## 参考资料
- [【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.im/post/5d901418518825539312f587)
- [promise、async和await之执行顺序的那点事](https://segmentfault.com/a/1190000015057278)

