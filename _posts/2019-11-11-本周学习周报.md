---
layout:     post
title:      2019-11-11-学习周报
subtitle:   JavaScript基础
date:       2019-11-11
author:     EWL
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - 前端
    - JavaScript
    - 基础
    - CSS3
---

## 学习总览
**JavaScript**
- 变量提升、函数提升
- 定时器

**CSS**
- 新增属性transition

----

## 学习内容
#### (1) 变量提升
根据MDN的一段描述，我们可以将变量提升理解为：
>从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

然而随着JavaScript的标准不断更新，一些旧的规则已经不再适用，比如变量提升在let/const出现之后就开始显得没有那么值得关注了，当然在var时代它还是相当重要的一个知识点，所以接下来的学习内容，我们就基于let/const以及var这两个时代背景去阐述一下变量提升的前世今生。

以下示例来自[https://www.cnblogs.com/liuhe688/p/5891273.html](https://www.cnblogs.com/liuhe688/p/5891273.html)
下面的代码中，我们在函数中声明一个变量，但是函数声明是在if语句块中，第一次访问该变量却是在if判断括号中
```
// var版本
function hoistVariable() {
    if (!foo) {
        var foo = 5;
    }

    console.log(foo); // 5
}

hoistVariable(); // 不报错，正常打印出5

// let版本
function hoistVariable() {
    if (!foo) {
        let foo = 5;
    }

    console.log(foo); // 5
}

hoistVariable(); // 报错 d is not defined.
```

在var时代，预编译阶段结束后，代码中的某一个作用域中的变量声明会被提升到作用域的前端，比如上面var版本的代码在预编译后会变成：
```
function hoistVariable() {
    var foo;
    if (!foo) {
        foo = 5;
    }

    console.log(foo); // 5
}
```
这样看起来是不是就好理解多了，但是为什么let版本会报错呢？首先我们需要知道let时代出现了块级作用域并禁止了变量的提升，那么在一个变量声明之前去访问它，内存中并不能找到该变量，就自然会抛出一个变量未声明的错误。
接下来再看一个例子：
```
// var版
var foo = 3;

function hoistVariable() {
    var foo = foo || 5;

    console.log(foo); // 5
}

hoistVariable();

// let版
let foo = 3;

function hoistVariable() {
    let foo = foo || 5; // 报错，禁止在foo变量初始化之前就去访问

    console.log(foo);
}

hoistVariable();
```

上面let版本的报错似乎不太常见，相关的内容可以参考[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init)。为啥会出现这么一个错误呢？我们需要了解一个概念叫做「临时性死区」，所谓的临时性死区就是被let声明的变量在其声明未被执行之前的区域都称为临时性死区，举例如下：
```
function tempDeadZone() {
  console.log(foo); // undefined
  console.log(boo); // ReferenceError, Cannot access 'boo' before initialization
  var foo = 5;
  let boo = 1;
}
tempDeadZone();
```
上述代码中，在```let boo = 1;```之前的区域都算是boo变量的临时性死区，在临时性死区访问boo变量时boo的声明还未被执行即初始化尚未完成。了解了临时性死区之后，let不存在变量提升这个结论瞬间就变得水到渠成。

此外，let时代还出现了一个概念——块级作用域，这在var时代是没有的，下面这段代码就充分说明了块级作用域对变量提升的影响：
```
// var版
function hoistVariable() {
    var foo = 3;
    
    {
        var foo = 5; // 这里的花括号写与不写结果是一样的
    }

    console.log(foo); // 5
}

hoistVariable();

// let版
function hoistVariable() {
    let foo = 3;
    
    {
        let foo = 5; // 在let时代，花括号就意味着块级作用域
    }

    console.log(foo); // 3
}

hoistVariable();
```
上述代码中，let版本中的花括号包裹的部分我们可以将其理解为hostVariable函数自身作用域中又包了一层内部的作用域，根据前面我回顾过的作用域访问顺序，很明显，外部作用域是不能访问内部作用域的，那么花括号中的```let foo = 5```对于外层的```let foo = 3```不会造成重复声明或者是值覆盖的问题，所以这就是为什么最后结果是3而不是5的原因。

#### (2) 函数提升
所谓的函数提升，也就是在函数声明之前就去调用函数，例如下面这段代码：
```
function hoistFunction() {
    foo(); // output: I am hoisted

    function foo() {
        console.log('I am hoisted');
    }
}

hoistFunction();
```
引擎把函数声明提升到了当前作用域的前端，换种明了的写法就是：
```
function hoistFunction() {
    function foo() {
        console.log('I am hoisted');
    }
    foo(); // output: I am hoisted
}

hoistFunction();
```
如果出现多个相同名称的函数声明，那么最后一个会覆盖前面的，例如：
```
function hoistFunction() {
    function foo() {
        console.log('I am hoisted');
    }

    foo(); // output: I am hoisted

    function foo() {
        console.log('I am hoisted again');
    }

    function foo() {
        console.log('This is the third time that I am hoisted');
    }
}

hoistFunction(); // 'This is the third time that I am hoisted'
```
函数的声明方式实际上不止上述这一种，还包括匿名函数表达式以及具名函数表达式，这几种方式在函数提升上面是有一些差异的。
先看一个简单的示例：
```
hoistFunction(); // TypeError,  hoistedFunction is not a function
var hoistedFunction = function () {
  console.log('hoisted first time');
};
```
其实上述的匿名函数表达式就相当于是一个变量声明，换一种写法就是：
```
var hoistedFunction; // 此时的hoistedFunction 被初始化成了undefined
hoistedFunction(); // 误将undefined作为函数调用会报TypeError
hoistedFunction = function() {
  console.log('hoisted first time');
}
```
接下来，我们再看一个稍微复杂的示例，如果将函数表达式和函数声明混写会发生什么呢：
```
function hoistFunction () {
    foo();
    var foo = function() {
      console.log('这是第一个foo声明');
    };

    foo();
    function foo() {
      console.log('这是第二个foo声明');
    }

    foo();
}

hoistFunction();
```
结果输出是：
```
这是第二个foo声明
这是第一个foo声明
这是第一个foo声明
```
为什么会是这么一个结果呢？我们可以站在编译器的角度来看一下上面那段代码，首先```var foo```会被提升，其次```function foo() { ... }```整个函数声明也会提升，那么形成的结果就会变成下面这个样子：
```
function hoistFunction () {
    // 被提升上来的foo函数表达式声明
    var foo;
    function foo() {
      console.log('这是第二个foo声明');
    }

    foo(); // 此时调用了函数foo，且同时存在一个值为undefined的变量foo

    foo = function() {
      console.log('这是第一个foo声明');
    }; // 将已经声明过的foo初始化为function () { console.log('这是第二个foo声明'); }

    // 以下两次调用都是指向上面这个匿名函数的foo变量
    foo();
    foo();
}

hoistFunction();
```
那如果我们再绕一圈，将上面代码中的函数声明和函数表达式对换位置，又会得到一个什么样的结果呢？
```
function hoistFunction () {
    foo();

    function foo() {
      console.log('这是第二个foo声明');
    }

    foo();
    
    var foo = function() {
      console.log('这是第一个foo声明');
    };

    foo();
}

hoistFunction();
```
先给出结果：
```
这是第二个foo声明
这是第二个foo声明
这是第一个foo声明
```
照着之前的思路再来整理一遍代码，将其写成预编译后的格式：
```
function hoistFunction () {
    // 被提升的部分
    function foo() {
      console.log('这是第二个foo声明');
    }
    var foo;

    // 两次调用foo，打印出两个"这是第二个foo声明"
    foo();
    foo();
    
    foo = function() {
      console.log('这是第一个foo声明');
    };
    // 调用指向上面匿名函数的foo函数变量
    foo();
}

hoistFunction();
```

#### (3) 哪个提升优先级更高
那到这里，还需要思考一个问题，在变量提升和函数提升里，哪一个级别更高？我们来看一段代码：
```
function testHoistLevel() {
    var foo = 123;
    function foo () {
      console.log('foo');
    }
    console.log('当前的foo'， foo);
}
testHoistLevel();
```

猜测结果是什么呢？打印出来的结果是函数还是123呢？先看一下结果：

![image.png](https://i.loli.net/2019/11/11/7fCIRs1mvzqyWYK.png)
