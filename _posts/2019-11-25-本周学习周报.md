---
layout:     post
title:      2019-11-25-学习周报
subtitle:   JavaScript基础
date:       2019-11-25
author:     EWL
header-img: img/bg-light.jpg
catalog: true
tags:
    - 前端
    - JavaScript
    - 基础
    - CSS3
---

## 学习总览
**JavaScript**
- JavaScript执行机制
- 同步与异步
- 定时器

**CSS**
- Flex布局
- 新增属性与选择器回顾

**HTML**
- 元素类型

**其他**
- 十一月份学习内容复习问答

----

## 学习内容

#### JavaScript执行机制

##### 词法作用域与动态作用域

什么是作用域？在《你不知道的JavaScript》（上）中这样描述作用域：变量住在哪里？换句话说，它们储存在哪里？最重要的是，程序需要时如何找到它们？这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为**作用域**。简言之，作用域就是一套用于存储以及查找变量的规则，我们可以借助作用域来找到我们需要的变量。

作用域又分为静态作用域与动态作用域，其中静态作用域又称为词法作用域，JavaScript就使用了静态作用域。这两类作用域的差别就在于静态作用域是在函数定义的时候就确定下来了，而动态作用域则是在函数调用时才能确定的。借助冴羽老师的博客示例，我们来做一个对比：
```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
```
我们已经说过JavaScript是静态作用域，所以这段代码在浏览器中会返回1，分析过程如下：
在foo定义的位置，foo函数的外层作用域就是全局作用域，所以foo函数的作用域链中其上层作用域中就已经有一个值为1的value了，所以当bar执行到foo函数时，foo执行的结果会打印其外层作用域中的1，而非其执行位置前值为2的value。所以如果JavaScript是动态作用域，此处输出的值就会变成2.

我们再来分析一个《JavaScript权威指南》中的代码示例：
```javascript
// demo01
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope(); // local scope

// demo02
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()(); // local scope
```

两个demo打印的结果都是```local scope```，原因就在于JavaScript是静态作用域，虽然这两段代码的结果一致，但是内部的执行顺序是有差异的。函数的作用域在其定义的时候就已经确定了，所以无论是先执行再返回还是先返回再执行，f函数获取的scope都是其定义位置前民的scope变量，当然这里第二个例子还涉及了闭包的概念，这里暂时按下不表，后面会详细描述。

##### 执行上下文栈
冴羽老师在执行上下文栈一章中给出了两个示例，在展开描述概念之前，我们先自己动手分析一下这两个示例，如下：
```javascript
// demo01
var foo = function () {
    console.log('foo1');
}

foo();  // foo1

var foo = function () {
    console.log('foo2');
}

foo(); // foo2

// demo02
function foo() {
    console.log('foo1');
}

foo();  // foo2

function foo() {
    console.log('foo2');
}

foo(); // foo2
```

这两个例子，我们都需要使用预编译阶段变量与函数提升的概念去理解，第一段代码中预编译阶段实际上仅捕获到一个变量foo，并且将其值初始化为undefined，所以我们改写一下demo01的代码会变成这样，如下：
```javascript
var foo = undefined;

foo = function () {
    console.log('foo1');
};

foo(); // foo1

foo = function () {
    console.log('foo2');
};

foo(); // foo2
```
改写后的代码就一目了然了，逐行执行后，我们每次执行的foo函数，foo变量指向的函数体每次都会因为新的赋值，而指向不同的函数体，从而打印出不同的结果。

以此类推，我们改写一下demo02，代码如下：
```javascript
function foo () {
  console.log('foo1');
}

function foo() {
  console.log('foo2');
}

foo();

foo();
```

这次的代码稍有不同，不同的点就在于demo01中所有的声明都是变量声明，而demo02中是函数声明，在前几次的学习笔记中提到过提升中函数声明优先级高于变量，而同名函数声明后面的会覆盖前面的，所以最终demo02中的第二个foo函数会覆盖第一个，因此后面两次执行结果都是foo2。
到这里，我们说完了提升与提升的优先等级这些预编译工作。
接下来，冴羽老师提出了这样一个问题：JavaScript引擎遇到一段怎样的代码时才会做的“准备工作”呢？
答：当JavaScript引擎遇到一段可执行的代码时。
那么什么是可执行的代码，在JavaScript中可执行的代码有三类：全局代码、函数代码以及eval代码。而问题中的准备工作就是“执行上下文”。

在一段JavaScript代码中，除了普通的全局代码之外，我们会创建众多的函数，那就意味着一段代码中会有非常多的执行上下文，用于管理这些上下文的工具就是执行上下文栈。
假设执行上下文栈是一个数组，当JavaScript引擎尝试着去解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候会像执行上下文栈中压入一个全局执行上下文，使用globalContext表示，当执行其他的函数时，就会按照执行的顺序依次将不同的函数执行上下文压入执行上下文栈，然后再按照先入后出的顺序依次执行完后出栈，知道只剩下全局执行上下文，如果整个应用程序结束，那么执行上下文栈会被清空。

我们来看一段代码，详细分析一下执行上下文栈：
```javascript
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

首先，加载整段脚本，我们往执行上下文栈中压入全局执行上下文，如下：
```javascript
const executeStack = [
  globalContext
];
```

然后执行fun1，并创建fun1执行上下文，压入栈：
```javascritp
// 遇到fun1
executeStack.push(fun1Context);

// 在fun1的内部遇到fun2
executeStack.push(fun2Context);

// 在fun2的内部遇到fun3
executeStack.push(fun3Context);

// 此时的中间状态，executeStack内部为[globalContext, fun1Context, fun2Context, fun3Context]

// 执行fun3，弹出其执行上下文
executeStack.pop();

// 执行fun2，弹出其执行上下文
executeStack.pop();

// 执行fun1，弹出其执行上下文
executeStack.pop();
```

根据上面这段分析，我们再来看看之前描述作用域的两段代码的执行上下文创建过程：
```javascript
// demo01
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope(); // local scope

// 初始化执行上下文栈
executeStack = [globalContext]
// checkscope执行
executeStack.push(checkscopeContext);
// checkscope内部执行f函数
executeStack.push(fContext);
// f执行结束，弹出
executeStack.pop();
// checkscope执行结束，弹出
executeStack.pop();

// demo02
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()(); // local scope

// 初始化执行上下文栈
executeStack = [globalContext]
// checkscope执行
executeStack.push(checkscopeContext);
// checkscope执行结束，弹出
executeStack.pop();
// checkscope内部返回的f函数执行
executeStack.push(fContext);
// f执行结束，弹出
executeStack.pop();
```

从上述两段执行上下文的创建与销毁的过程就可以看出，虽然两段代码的执行结果是相同的，但是执行上下文栈的内容变化是不同的。

##### 变量对象

在了解到函数执行的整个执行上下文栈的变化后，我们需要详细了解一下，在执行上下文栈中进进出出的执行上下文里面又有些什么内容。

对于每一个执行上下文，都有三个重要的属性：
- 变量对象（variable object）
- 作用域链
- this

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象（activation object）。

**全局上下文**

我们时常会听到一个词叫做“全局对象”，在解释什么叫全局对象以及全局上下文之前，我们依旧来看一段代码（运行环境是浏览器）：
```javascript
var a = 123;

function test() {
  return 'test';
}

console.log(this.a); // 123
console.log(window.a); // 123
console.log(this.window.a); // 123

console.log(this.test()); // test
console.log(window.test()); // test
console.log(this.window.test()); // test

console.log(this instanceof Object); // true

console.log(Math.random());
console.log(this.Math.random());
```

总的来说，全局对象有以下几点特点：
1. 可以用this来引用，在浏览器环境下this引用到的就是window对象
2. 全局对象是有Object实例化的一个对象
3. 预定了一些属性与方法
4. 作为全局变量以及函数的宿主
5. 在浏览器环境中，window属性指向自身，类似于arguments.callee指向函数自身

所以简而言之，全局对象就是全局上下文中的变量对象VO，存储着在当前上下文中声明的变量以及函数。

**函数上下文**

在函数上下文中

##### 作用域链
##### this
##### 执行上下文




----

## 资料参考
- [Difference between microTask and macroTask within a event loop context](https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context#)
- [Tasks, microTasks, queues ans schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
- [如何解释Event Loop面试官才满意？](https://zhuanlan.zhihu.com/p/72507900)
