---
layout:     post
title:      2019-12-05-学习周报
subtitle:   JavaScript基础
date:       2019-12-05
author:     EWL
header-img: img/bg-light.jpg
catalog: true
tags:
    - 前端
    - JavaScript
    - 基础
    - CSS3
---

2019-12-02-本周学习周报

## 学习总览
**JavaScript**
- this
- 闭包
- http协议

**CSS**
- grid布局
- CSS3新增属性以及新增选择器

**HTML**
- 标签种类

----

## 学习内容
#### this

在描述this之前，我们可以先来回顾一下《JavaScript语言精粹》中关于this的定义以及四种使用方式：

##### 定义
this是Javascript语言的一个关键字，它代表当前执行代码的环境对象，一般在函数内部使用。

① this的值通常是由所在函数的执行环境决定，也就是说要看函数是如何被调用的；
② 同一个函数每一次调用，this都可能指向不同的对象;

##### 不同环境下的this

**全局环境**
全局环境下，无论是否是严格模式，```this```都指向了全局对象。

```javascript
// 浏览器环境
console.log(this === window); // true
```

**函数环境**

在函数内部，this的值取决于函数被调用的方式

1. 普通调用(基于浏览器环境)
在非严格模式下，函数调用时，其内部的this会指向window全局对象；而严格模式下，函数内部的this会指向undefined。

```javascript
// 非严格模式
function foo() {
  console.log(this);
}
foo(); // Window

// 严格模式
function foo() {
  'use strict';
  console.log(this);
}
foo(); // undefined
```

2. bind绑定this
ES5推出了一个bind方法，用于改变当前函数的this指向，并且会返回一个与当前函数相同作用域以及函数体的函数，而且这个函数的this被永久地绑定到了bind的第一个参数对象上，无论这个函数如何调用又或者再使用其他的一些方法修改其this指向都是无效的。具体效果可以参考下面这段代码(非严格模式)：

```javascript
function foo() {
  return this.a;
}

foo(); // undefined

const obj1 = {
  a: 123
};

const obj2 = {
  a: 100
};

// 此时生成的bindFn01函数，其this被永久地绑定到了obj1上
const bindFn01 = foo.bind(obj1);
bindFn01(); // 123

bindFn01.call(obj2); // guess what? 返回值仍旧是123而非100
bindFn01(); // 作为window的方法调用，仍旧返回123
```

3. 作为对象的方法
当函数作为对象的方法被调用时，其this会自动指向该对象。

```javascript
const obj = {
  name: 'name',
  sayName: function() {
    console.log('this.name', this.name);
  }
};

obj.sayName(); // 'name'
```

>Tips:
>这样的调用行为是不受到函数声明位置或者方式的影响的，如果我们先声明函数然后再将该函数定义到对象上作为对象方法存在，我们依旧会得到相同的内容。

```javascript
function foo() {
  console.log(this.name);
}

var obj = {
  name: 'name'
};

obj.f = foo;

obj.f(); // 'name'

```

由上述代码可以得到一个结论，函数的this指向是作为某一个函数的方法被调用，这才是决定this的关键。

此外，上面的例子都是基于普通的函数声明展开的，如果我们改成函数表达式，最终的返回结果会是什么呢？我们接下来了解一下箭头函数的this值。

4. 箭头函数
箭头函数的this会与封闭词法环境保持一致，如果是在全局环境，则会指向全局对象，其表现用一句话形容就是箭头函数没有自己的this值，而是会继承父层环境的this。此外，箭头函数对call/apply/bind免疫，这是很重要的一个知识点，后面会给出一个笔试题做以验证。

```javascript
// 全局环境
const globalThis = this;
const foo = () => this;

globalThis === foo(); // true

// 作为全局对象方法
const obj = {
  name: 'name',
  sayName: () => {
    console.log(this.name);
  }
};
obj.sayName(); // undefined

// 在函数中声明(该示例来自MDN)
// 创建一个含有bar方法的obj对象，
// bar返回一个函数，
// 这个函数返回this，
// 这个返回的函数是以箭头函数创建的，
// 所以它的this被永久绑定到了它外层函数的this。
// bar的值可以在调用中设置，这反过来又设置了返回函数的值。
var obj = {
  bar: function() {
    // -----个人评注----- 
    // this指向bar函数指向的this也就是obj对象
    var x = (() => this);
    return x;
  }
};

// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。
// 将返回的函数的引用赋值给fn。
var fn = obj.bar();

// 直接调用fn而不设置this，
// 通常(即不使用箭头函数的情况)默认为全局对象
// 若在严格模式则为undefined
console.log(fn() === obj); // true

// 但是注意，如果你只是引用obj的方法，
// 而没有调用它
var fn2 = obj.bar;
// 那么调用箭头函数后，this指向Window，因为它从 bar 继承了this。
// -----个人评注----- 
// fn2是在全局环境下声明的，所以是作为Window的方法执行的，fn2的this指向Window
console.log(fn2()() == Window); // true

// -----个人评注----- 
// 将上述代码进行改写，如下
var fn2 = function () {
  var x = (() => this);
  return x;
};

// 第一次执行fn2是谁在调用fn2呢？很明显是Window全局对象，所以this指向了Window；而fn2()的返回值再次执行的时候就会打印出刚才调用fn2的对象，也就是Window
fn2()();
```

最后，我们来看一道笔试题：

```javascript
function fun () {
    return () => {
        return () => {
            return () => {
            console.log(this.name)
                    }
                }
        }
}
var f = fun.call({name: 'foo'}); // 对普通function声明绑定成功
var t1 = f.call({name: 'bar'})()(); // 无效
var t2 = f().call({name: 'baz'})(); // 无效
var t3 = f()().call({name: 'qux'}); // 无效

// 最终结果是返回三个foo
```

试想，如果我们将上述代码中第一层的箭头函数改为匿名函数声明，返回结果会是什么呢？

```javascript
function fun () {
    return function () {
        return () => {
            return () => {
            console.log(this.name)
                    }
                }
        }
}
var f = fun.call({name: 'foo'}); // 对普通function声明绑定成功
var t1 = f.call({name: 'bar'})()(); // bar
var t2 = f().call({name: 'baz'})(); // 'undefined'
var t3 = f()().call({name: 'qux'}); // 'undefined'
```

我们来分析一波，首先 fun.call({name: 'foo'}) 会返回一个匿名函数，所以变量f实际上指向一个匿名函数体，所以对一个匿名函数使用call是可以绑定并执行成功的，所以第二行绑定到 { name: 'bar' } 上是会成功的，此时打印出bar；而接下来f执行的时候是作为全局变量Window的方法来执行的，所以里面几层箭头函数的this会跟着外层的f函数一起指向Window，而Window中并没有声明过一个名为name的变量，所以打印出undefined，第三行同理。
最后，我们来整理一下第二版代码：

```javascript
// 省略fun声明，直接展开f/t1/t2/t3的结果
var f = function () {
  return () => {
    return () => {
      // 此处的this与最外层的匿名函数的this一致
      console.log(this.name);
    };
  };
};
f.call({ name: 'bar' }); // 函数f的this指向{ name: 'bar' }

f().call({ name: 'baz' });
// ----我是分割线---- 
// 上面这行代码分割成两部分
// 首先是f()这里我们换个写法-->window.f()
// 这下就很清晰了，函数f内部的this指向全局对象Window，所以里面的箭头函数this也会指向Window，所以最终打印name的时候，会去Window对象中寻找name属性，很明显找不到就返回undefined
// 其次是call绑定，f()返回的结果是箭头函数，绑定必然会失败，所以仍旧跟随其外层函数返打印Window中的name
```

5. 原型链中的this
6. 作为构造函数
7. 作为一个DOM事件处理函数
8. 作为一个内联事件处理函数

**关于this的取值**

##### 结合规范


## 资料参考

- [MDN对this的解释](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)
- []()
